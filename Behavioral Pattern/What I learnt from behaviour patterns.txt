ğŸ‘‰ BEHAVIOUR DESIGN PATTERN
-----------------------------

These patterns focus on communication and the interaction between objects. They help objects cooperate by defining the flow of control and data in complex systems.

1ï¸âƒ£ Chain of Responsibility:

    Â» Chain of Responsibility pattern will allow the request to handle through chains. 
    Â» Each chain (handlers) will decide to pass or reject the value to next chain.


Example:

    Â» Here we habe created 5 (1 main 4 inherit classes). Where the main class defines the how the value should be check and proceed for result (pass / reject).
    Â» Our example is about connecting to proper supportRequest team based on client request.

2ï¸âƒ£ Command Pattern:

    Â» Command pattern is used to improve the decoupling of between sender and receiver through commands. After the command execute the other actions will be performed.
    Â» Command Pattern has 4 components: 
        Command()   -> A object encapsulate the request and have execute() method to perform.
        Invoker()   -> Call the command execute method whenever the action is needed.
        Receiver()  -> All logic will be implemented here
        Client      -> Create the invoker and command as objects.

Example:

    Â» I have created a simple appliances on / off method in receiver. From client code I have created the objects for both commands and invoker.

3ï¸âƒ£ Iterator Pattern:

    Â» Iterator Pattern is used to provide a way to access the elements of a collection sequentially without exposing its underlying representation (like an array or list). This pattern helps in decoupling the traversal logic from the collection structure, allowing for a more flexible and manageable way to iterate over different types of collections.
    Â» Iterator Pattern has 3 main components:
        Iterator: This interface defines the methods for accessing and traversing the elements in a collection, typically including methods like hasNext() and next().
        Concrete Iterator: This class implements the Iterator interface and maintains the current position in the iteration over the collection.
        Aggregate: This interface defines a method for creating an iterator. It may also have methods to manage the collection (like adding or removing items)  provides a concrete implementation of the collection, allowing an iterator to traverse its items.

4ï¸âƒ£ Mediator Pattern:

    Â» This pattern reduces confusion between objects. Restricts direct communication between objects and communicate through mediator object.

Example:
    Â» Create a small chatting program, where added group `RoomChat` and added methods to register & send.
    Â» All transcation will be passes through mediator object and send and display those message to others.

5ï¸âƒ£ Memento Pattern:

    Â» Memento is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation.
    Â» Memento Pattern has 3 main components:
        Orginator: The Originator class can produce snapshots of its own state, as well as restore its state from snapshots when needed.
        Memento: The Memento is a value object that acts as a snapshot of the originatorâ€™s state. Itâ€™s a common practice to make the memento immutable and pass it the data only once, via the constructor.
        Caretaker: The Caretaker knows not only â€œwhenâ€ and â€œwhyâ€ to capture the originatorâ€™s state, but also when the state should be restored.

6ï¸âƒ£ Observer Pattern:

    Â» Observer patterns is used to notify to the subscribers objects which they are looking for update.
    Â» Observer Pattern has 2 main components:
        Publisher: The main object which is making changes in that object.
        Subscriber: The objects which they are looking for notify to them from publisher for particular need.
Example:
        Â» Here I have created a publisher file to notify to the subscribers on updating on temperature.
        Â» There are some subscribers (currently -2), which are WebUI & MobileUI they will getting notifed once there is change in waited data (temperature).

7ï¸âƒ£ State Pattern:

    Â» In State pattern, object functionalities are altered based on state.
    Â» State Pattern has 2 main components:
        State: This component defines the behaviour of each state.
        Context: This componenet has reference to the current state and delegate based on state.
Example:
        Â» Here I have created a state file with 3 states of phone.
        Â» Once the client code is passes the value based on the state the behavior will change.